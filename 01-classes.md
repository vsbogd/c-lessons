# This

Рассмотрим следующий код:
```cpp
#include <iostream>

struct Lamp {
    int on;
    void turn(int _on);
};

void Lamp::turn(int _on) {
    on = _on;
}

int main() {
    Lamp a, b;

    a.turn(1);
    b.turn(0);

    std::cout << "a.on = " << a.on << std::endl;
    std::cout << "b.on = " << b.on << std::endl;

    return 0;
}
```

Если мы скомпилируем и выполним эту программу, то мы убедимся, что поле `on` у
структур `a` и `b` меняется независимо. Но откуда метод `turn` знает с каким
экземпляром структуры он работает? Ведь в коде метода нет никакого указания на
это.

Дело в том, что на самом деле метод `turn` имеет один дополнительный скрытый
параметр `this` и настоящая реализация метода выглядит так:
```cpp
void Lamp::turn(Lamp *this, int _on) {
    this->on = _on;
}
```

Компилятор автоматически добавляет этот параметр в каждый метод и так же
автоматически передает его в каждом вызове метода. В данном случае вызов метода
`turn` будет выглядет следующим образом:
```cpp
    Lamp::turn(&a, 1); // a.turn(1);
```

Если бы `turn` был [виртуальным методом](#виртуальный-метод), то вызов выглядел
бы ещё сложнее:
```cpp
    a.vtable.turn(&a, 1); // a.turn(1);
```

Из этих двух записей видно, почему параметр `this` скрыт.  Запись `a.tune(1)`
выглядит гораздо лаконичнее и не требует от программиста: указания класса -
компилятор берет класс из типа переменной `a`; и двойного использования
переменной `a` - компилятор сам подставляет скрытый параметр, упрощая написание
кода.

Кроме того, чтобы упростить жизнь программисту, компилятор автоматически
подставляет `this->` перед каждым именем поля в коде метода, в тех случаях,
когда имя поля не совпадает с именем локальной переменной. Если есть локальная
переменная с таким же именем, то компилятор будет считать, что имя указывает
именно на неё.

Например, в такой реализации:
```cpp
void Lamp::turn(int on) {
    on = on;
}
```
значение параметра `on` будет присвоено самому этому параметру и поле
`Lamp::on` останется [непроинициализированным](00-pointers#инициализация).
Чтобы исправить эту ошибку, нужно явно сказать компилятору, что мы обращаемся к
полю. Мы можем это сделать вручную используя скрытый параметр `this`:
```cpp
void Lamp::turn(int on) {
    this->on = on;
}
```

В некоторых языках программирования ссылка на текущий объект в методе не
является неявным параметром, либо обязательно используется при доступе к полям
класса. Например в Python программист сам добавляет параметр `self` в сигнатуру
метода и для обращения к полю класса всегда нужно писать `self.`.
