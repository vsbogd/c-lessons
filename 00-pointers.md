# Память

Представьте себе длинную последовательность клеток. Будем считать, что в каждой
клетке можно записать одно число от 0 до 255. То есть каждая клетка вмещает
ровно один байт информации. Пронумеруем клетки начиная с 0. Я буду использовать
шестнадцатеричные числа для нумерации. Чтобы отличать шестнадцатеричные числа
от десятичных я буду писать перед ними `0x` как это принято в C. Например, вот
последовательность из клеток, пронумерованных от 0 до 65535:
```
       |---|
0x0000 |   | 0
       |---|
0x0001 |   | 1
       |---|
0x0002 |   | 2
       |---|
       ...
       |---|
0xFFFD |   | 65533
       |---|
0xFFFE |   | 65534
       |---|
0xFFFF |   | 65535
       |---|
```

Мы изобразили модель памяти компьютера. Пустые клетки - это ячейки памяти.
Номер ячейки памяти называется адресом этой ячейки. Я использовал только 2
байта (16 бит) для нумерации ячеек, поэтому всего в такой таблице можно
поместить 2^16 = 65536 байт. Когда то это было все, что мог адресовать
процессор. Такие процессоры назывались 16-ти разрядными по количеству двоичных
разрядов на адрес в памяти, которые они могут использовать. Их сменили 32-х
разрядные процессоры, которые могли адресовать до 2^32 = 4 Гб памяти. Но и
этого оказалось недостаточно. Современные процессоры 64-х разрядные. Они могут
адресовать до 2^64 байт - это очень много. На практике компьютеры имеют гораздо
меньше памяти. Хотя объем памяти мощных компьютеров измеряется сотнями
гигабайт, все же это гораздо меньше, чем 18 квинтиллионов байт, доступных для
адресации 64 битами.

Изображать память в виде длинного столбца или строки не всегда удобно. Поэтому
чаще мы будем изображать её в виде таблицы. Пусть каждая строчка содержит 16
ячеек или байт, тогда такая таблица будет выглядеть примерно так:
```
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
0x0000 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
0x0010 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
       ...
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
0xFFF0 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
```

Номера столбцов - это порядковый номер ячейки в строке от 0x0 до 0xF. Перед
каждой строчкой написан номер нулевой ячейки в этой строке: 0x0000 - это ячейка
0, 0x0010 - это ячейка номер 16 и так далее. Первая ячейка последней строки
имеет номер 0xFFF0 - ячейка номер 65520.

Чтобы получить полный номер ячейки, нужно умножить номер строки на количество
ячеек в строке (то есть на 16) и прибавить порядковый номер ячейки в этой
строке. Например, десятая ячейка в трехсотой строке имеет номер:
```
0x12C * 0x10 + 0xA = 0x12CA
```
Вот почему удобно нумеровать строки и ячейки начиная с 0, а не с 1. Если бы мы
все нумеровали с 1, то пришлось бы дополнительно вычитать 1 из номера строки и
прибавлять 1 к номеру ячейки. Количество операций возросло бы вдвое.

Подведем итог. Память компьютера - это длинный список ячеек, каждая из которых
хранит 1 байт информации и имеет свой номер - адрес. Количество битов в адресе
определяет с каким максимальным объемом памяти может работать процессор. Это
число называется разрядностью шины данных процессора. Все
[переменные](#переменная) программы хранятся в памяти.

# Переменная

Каждый раз, когда в программе объявляется переменная, компилятор заботится о
том, чтобы при работе программы для неё было выделено место в памяти. Если
переменная занимает несколько ячеек, то они идут в памяти одна за другой.
Количество выделенных байтов памяти зависит от размера переменной. Например,
переменная типа `int` занимает 4 байта, поэтому если мы объявим переменную `int
a`, то в памяти это будет выглядеть так:

```
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
0x0000 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
       ...
       |---|---|---|---|---|---|---|---|= int a ========---|---|---|---|
0x1230 |   |   |   |   |   |   |   |   |               |   |   |   |   |
       |---|---|---|---|---|---|---|---|================---|---|---|---|
       ...
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
0xFFF0 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
```

На картинке переменная `a` расположена в памяти по адресу 0x1238 и занимает 4
байта расположенных последовательно. Адрес переменной является почти случайным
и может быть различным от запуска к запуску программы.

Компилятор заботится о том, чтобы каждый раз, когда в программе используется
переменная `a`, программа обращалась к одному и тому же адресу. Переменная не
двигается в памяти, но если она является локальной - как большинство
переменных - то место в памяти выделяется не при запуске программы, а при
запуске функции, которая содержит переменную, и освобождается при выходе из
функции. Для этого используется механизм, который называется [стеком](#стек).

Когда мы записываем значение в переменную, это значение попадает в ячейки
памяти, соответствующие имени переменной:

```
int a = 6;

       ...
       |---|---|---|---|---|---|---|---|= int a ========---|---|---|---|
0x1230 |   |   |   |   |   |   |   |   |             6 |   |   |   |   |
       |---|---|---|---|---|---|---|---|================---|---|---|---|
       ...

int b = 7;
       ...
       |---|---|---|---|= int b =======|= int a ========---|---|---|---|
0x1230 |   |   |   |   |             7 |             6 |   |   |   |   |
       |---|---|---|---|===============|================---|---|---|---|
       ...

a = a * b;
       ...
       |---|---|---|---|= int b =======|= int a ========---|---|---|---|
0x1230 |   |   |   |   |             7 |            42 |   |   |   |   |
       |---|---|---|---|===============|================---|---|---|---|
       ...
```

Важно понимать, что даже когда две переменных, объявленных в разных блоках
программы, имеют одно и то же имя, они все равно имеют разные адреса,
потому что это разные переменные. Например, переменные:
```
int a = 6;
{
    int a = 7;
}
```
в памяти будут выглядеть:
```
       ...
       |---|---|---|---|= int a =======|= int a ========---|---|---|---|
0x1230 |   |   |   |   |             7 |             6 |   |   |   |   |
       |---|---|---|---|===============|================---|---|---|---|
       ...
```

# Указатель

Чтобы передать значение переменной из функции в функцию обычно нужно его
скопировать. Например, у нас есть такая программа на C:
```c
int inc(int n) {   /* 01 */
    return n + 1;  /* 02 */
}                  /* 03 */
                   /* 04 */
void main() {      /* 05 */
    int a = 41;    /* 06 */
    a = inc(a);    /* 07 */
}                  /* 08 */
```

Давайте выполним её по шагам и будем смотреть как меняются данные в памяти.
Сначала выполняется функция `main`, где мы объявляем переменную `a` и
записываем в нее число `41`:
```
void main() {      /* 05 */
    int a = 41;    /* 06 */
       ...
       |---|---|---|---|---|---|---|---|= int a ========---|---|---|---|
0x1230 |   |   |   |   |   |   |   |   |            41 |   |   |   |   |
       |---|---|---|---|---|---|---|---|================---|---|---|---|
       ...
```
Затем происходит вызов функции `inc`, в этот момент в памяти будет выделено
место под новую переменную `n` и значение переменной `a` будет скопировано в
`n`.
```
int inc(int n) {   /* 01 */
    return n + 1;  /* 02 */
}                  /* 03 */
       ...
       |---|---|---|---|= int n =======|= int a ========---|---|---|---|
0x1230 |   |   |   |   |            41 |            41 |   |   |   |   |
       |---|---|---|---|===============|================---|---|---|---|
       ...
```
После того, как `inc` выполнит сложение и вернет результат, он будет записан в
переменную `a`. Место под переменную `n` будет освобождено:
```
    a = inc(a);    /* 07 */
}                  /* 08 */
       ...
       |---|---|---|---|---|---|---|---|= int a ========---|---|---|---|
0x1230 |   |   |   |   |               |            42 |   |   |   |   |
       |---|---|---|---|---|---|---|---|================---|---|---|---|
       ...
```

Иногда копировать данные неэффективно. Например, мы хотим передать в функцию
большой набор данных, но она будет данные только читать. Скопировать данные все
равно придется, потому что под локальные переменные функции будет выделено
новое место в памяти. Или, например, функция меняет только маленький кусочек
данных. В этом случае данные придется скопировать два раза: один раз, чтобы
передать их в функцию, а второй раз, чтобы вернуть результат.

Как нам передать данные в функцию не копируя их? Ведь данные уже лежат в
памяти, нам нужно только рассказать функции где их брать. Мы могли бы передать
адрес данных в памяти и функция могла бы их найти по адресу, а не по имени
переменной. Переменная, в которой хранится адрес данных в памяти, называется
указателем.

Для работы с адресами (указателями) в C есть два специальных оператора.
Оператор `&` позволяет вычислить адрес переменной в памяти. Оператор `*`
указывает компилятору, что он должен производить операции не с содержимым
переменной, а с содержимым адреса, который лежит в переменной. Откуда
компилятор знает сколько данных в переменной, на которую ссылается указатель?
Об этом компилятору говорит тип указателя, который состоит из типа данных, на
которые ссылается указатель и символа `*` - признака типа "указатель".
Например, объявление `int *p;` говорит компилятору о том, что `p` - это
переменная содержащая адрес в памяти (`*`) целого числа (`int`). Пробел в
объявлении можно ставить в любом месте, так что записи: `int* p;`, `int *p;` и
`int*p;` будут означать одно и то же.

Перепишем наш код, с использованием указателя. На этот раз нам не нужно
возвращать значение, мы можем изменить его прямо в памяти:
```c
void inc(int* p) { /* 01 */
    *p = *p + 1;   /* 02 */
}                  /* 03 */
                   /* 04 */
void main() {      /* 05 */
    int a = 41;    /* 06 */
    inc(&a);       /* 07 */
}                  /* 08 */
```

Как и раньше сначала выполняется функция `main`, где мы объявляем переменную
`a` и записываем в нее число `41`:
```
void main() {      /* 05 */
    int a = 41;    /* 06 */
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       ...
       |---|---|---|---|---|---|---|---|= int a ========---|---|---|---|
0x1230 |   |   |   |   |   |   |   |   |            41 |   |   |   |   |
       |---|---|---|---|---|---|---|---|================---|---|---|---|
       ...
```
Затем происходит вызов функции `inc`, но на этот раз мы передаем не значение
переменной, а указатель на неё. Указатель - это тоже переменная, поэтому под
неё тоже будет выделено место в памяти. И в это место будет записан адрес
переменной `a`, то есть `0x1238`. Адрес мы получаем используя оператор `&`:
```
    inc(&a);       /* 07 */

void inc(int* p) { /* 01 */
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       ...
       |---|---|---|---|= int* p ======|= int a ========---|---|---|---|
0x1230 |   |   |   |   |    0x00001238 |            41 |   |   |   |   |
       |---|---|---|---|===============|================---|---|---|---|
       ...
```
Теперь новое значение окажется в переменной `a` до возврата из функции.
Ведь `inc` производит действие над содержимым адреса в памяти, а не над
переданным значением. `*p` как бы является новым именем переменной, значение
которой лежит по адресу `p`.
```
    *p = *p + 1;   /* 02 */
}                  /* 03 */
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       ...
       |---|---|---|---|= int* p ======|= int a ========---|---|---|---|
0x1230 |   |   |   |   |    0x00001238 |            42 |   |   |   |   |
       |---|---|---|---|===============|================---|---|---|---|
       ...
```
После возврата из функции локальная переменная `p` будет удалена из памяти, а в
`a` останется измененное значение.
```
    inc(&a);       /* 07 */
}                  /* 08 */
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       ...
       |---|---|---|---|---|---|---|---|= int a ========---|---|---|---|
0x1230 |   |   |   |   |               |            42 |   |   |   |   |
       |---|---|---|---|---|---|---|---|================---|---|---|---|
       ...
```

Указатель - это переменная, содержащая адрес другой переменной в памяти. На
самом деле стандарт C такой нестрогий, что он позволяет хранить в указателе
вообще любой адрес и даже модифицировать его просто записывая в
переменную-указатель значение напрямую. Например, следующий код успешно
скомпилируется:
```c
void inc() {
    int *p = (int *)0x1238;
    *p = *p + 1;
}
void main() {
    int a = 41;
    inc();
}
```

Разумеется в реальных программах так делать почти никогда не следует по той
причине, что угадать адрес в памяти другой переменной в общем случае
невозможно. Поэтому если вы запустите такую программу, то она закончится
ошибкой. В качестве упражнения проверьте, какая ошибка будет выведена вашей
операционной системой.

Однако, есть случаи, когда обращение по конкретному адресу будет работать.
Например, часть адресов может быть зарезервирована для обращения к различным
устройствам компьютера. Запись и чтение в такие адреса не помещает значения в
оперативную память, а передает их для обработки устройству расширения. C
позволяет манипулировать памятью напрямую, что более строгие языки, вроде Java,
делать не позволяют. Такая нестрогость C - одна из причин его популярности в
низкоуровневой разработке.
