# Память

Представьте себе длинную последовательность клеток. Будем считать, что в каждой
клетке можно записать одно число от 0 до 255. То есть каждая клетка вмещает
ровно один байт информации. Пронумеруем клетки начиная с 0. Я буду использовать
шестнадцатеричные числа для нумерации. Чтобы отличать шестнадцатеричные числа
от десятичных я буду писать перед ними `0x` как это принято в C. Например, вот
последовательность из клеток, пронумерованных от 0 до 65535:
```
       |---|
0x0000 |   | 0
       |---|
0x0001 |   | 1
       |---|
0x0002 |   | 2
       |---|
       ...
       |---|
0xFFFD |   | 65533
       |---|
0xFFFE |   | 65534
       |---|
0xFFFF |   | 65535
       |---|
```

Мы изобразили модель памяти компьютера. Пустые клетки - это ячейки памяти.
Номер ячейки памяти называется адресом этой ячейки. Я использовал только 2
байта (16 бит) для нумерации ячеек, поэтому всего в такой таблице можно
поместить 2^16 = 65536 байт. Когда то это было все, что мог адресовать
процессор. Такие процессоры назывались 16-ти разрядными по количеству двоичных
разрядов на адрес в памяти, которые они могут использовать. Их сменили 32-х
разрядные процессоры, которые могли адресовать до 2^32 = 4 Гб памяти. Но и
этого оказалось недостаточно. Современные процессоры 64-х разрядные. Они могут
адресовать до 2^64 байт - это очень много. На практике компьютеры имеют гораздо
меньше памяти. Хотя объем памяти мощных компьютеров измеряется сотнями
гигабайт, все же это гораздо меньше, чем 18 квинтиллионов байт, доступных для
адресации 64 битами.

Изображать память в виде длинного столбца или строки не всегда удобно. Поэтому
чаще мы будем изображать её в виде таблицы. Пусть каждая строчка содержит 16
ячеек или байт, тогда такая таблица будет выглядеть примерно так:
```
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
0x0000 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
0x0010 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
       ...
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
0xFFF0 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
```

Номера столбцов - это порядковый номер ячейки в строке от 0x0 до 0xF. Перед
каждой строчкой написан номер нулевой ячейки в этой строке: 0x0000 - это ячейка
0, 0x0010 - это ячейка номер 16 и так далее. Первая ячейка последней строки
имеет номер 0xFFF0 - ячейка номер 65520.

Чтобы получить полный номер ячейки, нужно умножить номер строки на количество
ячеек в строке (то есть на 16) и прибавить порядковый номер ячейки в этой
строке. Например, десятая ячейка в трехсотой строке имеет номер:
```
0x12C * 0x10 + 0xA = 0x12CA
```
Вот почему удобно нумеровать строки и ячейки начиная с 0, а не с 1. Если бы мы
все нумеровали с 1, то пришлось бы дополнительно вычитать 1 из номера строки и
прибавлять 1 к номеру ячейки. Количество операций возросло бы вдвое.

Подведем итог. Память компьютера - это длинный список ячеек, каждая из которых
хранит 1 байт информации и имеет свой номер - адрес. Количество битов в адресе
определяет с каким максимальным объемом памяти может работать процессор. Это
число называется разрядностью шины данных процессора. Все
[переменные](#переменная) программы хранятся в памяти.

# Переменная

Каждый раз, когда в программе объявляется переменная, компилятор заботится о
том, чтобы при работе программы для неё было выделено место в памяти. Если
переменная занимает несколько ячеек, то они идут в памяти одна за другой.
Количество выделенных байтов памяти зависит от размера переменной. Например,
переменная типа `int` занимает 4 байта, поэтому если мы объявим переменную `int
a`, то в памяти это будет выглядеть так:

```
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
0x0000 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
       ...
       |---|---|---|---|---|---|---|---|= int a ========---|---|---|---|
0x1230 |   |   |   |   |   |   |   |   |               |   |   |   |   |
       |---|---|---|---|---|---|---|---|================---|---|---|---|
       ...
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
0xFFF0 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
```

На картинке переменная `a` расположена в памяти по адресу 0x1238 и занимает 4
байта расположенных последовательно. Адрес переменной является почти случайным
и может быть различным от запуска к запуску программы. Размер переменной
зависит от типа переменной. Чтобы узнать размер переменной можно
воспользоваться оператором [sizeof](#sizeof). Мы будем считать, что переменная
типа `int` занимает 4 байта, хотя это число может быть разнным для различных
платформ.

Компилятор заботится о том, чтобы каждый раз, когда в программе используется
переменная `a`, программа обращалась к одному и тому же адресу. Переменная не
двигается в памяти, но если она является локальной - как большинство
переменных - то место в памяти выделяется не при запуске программы, а при
запуске функции, которая содержит переменную, и освобождается при выходе из
функции. Для этого используется механизм, который называется [стеком](#стек).

Когда мы записываем значение в переменную, это значение попадает в ячейки
памяти, соответствующие имени переменной:

```
int a = 6;

       ...
       |---|---|---|---|---|---|---|---|= int a ========---|---|---|---|
0x1230 |   |   |   |   |   |   |   |   |             6 |   |   |   |   |
       |---|---|---|---|---|---|---|---|================---|---|---|---|
       ...

int b = 7;
       ...
       |---|---|---|---|= int b =======|= int a ========---|---|---|---|
0x1230 |   |   |   |   |             7 |             6 |   |   |   |   |
       |---|---|---|---|===============|================---|---|---|---|
       ...

a = a * b;
       ...
       |---|---|---|---|= int b =======|= int a ========---|---|---|---|
0x1230 |   |   |   |   |             7 |            42 |   |   |   |   |
       |---|---|---|---|===============|================---|---|---|---|
       ...
```

Важно понимать, что даже когда две переменных, объявленных в разных блоках
программы, имеют одно и то же имя, они все равно имеют разные адреса,
потому что это разные переменные. Например, переменные:
```
int a = 6;
{
    int a = 7;
}
```
в памяти будут выглядеть:
```
       ...
       |---|---|---|---|= int a =======|= int a ========---|---|---|---|
0x1230 |   |   |   |   |             7 |             6 |   |   |   |   |
       |---|---|---|---|===============|================---|---|---|---|
       ...
```

# Указатель

Чтобы передать значение переменной из функции в функцию обычно нужно его
скопировать. Например, у нас есть такая программа на C:
```c
int inc(int n) {   /* 01 */
    return n + 1;  /* 02 */
}                  /* 03 */
                   /* 04 */
void main() {      /* 05 */
    int a = 41;    /* 06 */
    a = inc(a);    /* 07 */
}                  /* 08 */
```

Давайте выполним её по шагам и будем смотреть как меняются данные в памяти.
Сначала выполняется функция `main`, где мы объявляем переменную `a` и
записываем в нее число `41`:
```
void main() {      /* 05 */
    int a = 41;    /* 06 */
       ...
       |---|---|---|---|---|---|---|---|= int a ========---|---|---|---|
0x1230 |   |   |   |   |   |   |   |   |            41 |   |   |   |   |
       |---|---|---|---|---|---|---|---|================---|---|---|---|
       ...
```
Затем происходит вызов функции `inc`, в этот момент в памяти будет выделено
место под новую переменную `n` и значение переменной `a` будет скопировано в
`n`.
```
int inc(int n) {   /* 01 */
    return n + 1;  /* 02 */
}                  /* 03 */
       ...
       |---|---|---|---|= int n =======|= int a ========---|---|---|---|
0x1230 |   |   |   |   |            41 |            41 |   |   |   |   |
       |---|---|---|---|===============|================---|---|---|---|
       ...
```
После того, как `inc` выполнит сложение и вернет результат, он будет записан в
переменную `a`. Место под переменную `n` будет освобождено:
```
    a = inc(a);    /* 07 */
}                  /* 08 */
       ...
       |---|---|---|---|---|---|---|---|= int a ========---|---|---|---|
0x1230 |   |   |   |   |               |            42 |   |   |   |   |
       |---|---|---|---|---|---|---|---|================---|---|---|---|
       ...
```

Иногда копировать данные неэффективно. Например, мы хотим передать в функцию
большой набор данных, но она будет данные только читать. Скопировать данные все
равно придется, потому что под локальные переменные функции будет выделено
новое место в памяти. Или, например, функция меняет только маленький кусочек
данных. В этом случае данные придется скопировать два раза: один раз, чтобы
передать их в функцию, а второй раз, чтобы вернуть результат.

Как нам передать данные в функцию не копируя их? Ведь данные уже лежат в
памяти, нам нужно только рассказать функции где их брать. Мы могли бы передать
адрес данных в памяти и функция могла бы их найти по адресу, а не по имени
переменной. Переменная, в которой хранится адрес данных в памяти, называется
указателем.

Для работы с адресами (указателями) в C есть два специальных оператора.
Оператор `&` позволяет вычислить адрес переменной в памяти. Оператор `*`
указывает компилятору, что он должен производить операции не с содержимым
переменной, а с содержимым адреса, который лежит в переменной. Откуда
компилятор знает сколько данных в переменной, на которую ссылается указатель?
Об этом компилятору говорит тип указателя, который состоит из типа данных, на
которые ссылается указатель и символа `*` - признака типа "указатель".
Например, объявление `int *p;` говорит компилятору о том, что `p` - это
переменная содержащая адрес в памяти (`*`) целого числа (`int`). Пробел в
объявлении можно ставить в любом месте, так что записи: `int* p;`, `int *p;` и
`int*p;` будут означать одно и то же.

Перепишем наш код, с использованием указателя. На этот раз нам не нужно
возвращать значение, мы можем изменить его прямо в памяти:
```c
void inc(int* p) { /* 01 */
    *p = *p + 1;   /* 02 */
}                  /* 03 */
                   /* 04 */
void main() {      /* 05 */
    int a = 41;    /* 06 */
    inc(&a);       /* 07 */
}                  /* 08 */
```

Как и раньше сначала выполняется функция `main`, где мы объявляем переменную
`a` и записываем в нее число `41`:
```
void main() {      /* 05 */
    int a = 41;    /* 06 */
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       ...
       |---|---|---|---|---|---|---|---|= int a ========---|---|---|---|
0x1230 |   |   |   |   |   |   |   |   |            41 |   |   |   |   |
       |---|---|---|---|---|---|---|---|================---|---|---|---|
       ...
```
Затем происходит вызов функции `inc`, но на этот раз мы передаем не значение
переменной, а указатель на неё. Указатель - это тоже переменная, поэтому под
неё тоже будет выделено место в памяти. И в это место будет записан адрес
переменной `a`, то есть `0x1238`. Адрес мы получаем используя оператор `&`:
```
    inc(&a);       /* 07 */

void inc(int* p) { /* 01 */
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       ...
       |---|---|---|---|= int* p ======|= int a ========---|---|---|---|
0x1230 |   |   |   |   |    0x00001238 |            41 |   |   |   |   |
       |---|---|---|---|===============|================---|---|---|---|
       ...
```
Теперь новое значение окажется в переменной `a` до возврата из функции.
Ведь `inc` производит действие над содержимым адреса в памяти, а не над
переданным значением. `*p` как бы является новым именем переменной, значение
которой лежит по адресу `p`.
```
    *p = *p + 1;   /* 02 */
}                  /* 03 */
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       ...
       |---|---|---|---|= int* p ======|= int a ========---|---|---|---|
0x1230 |   |   |   |   |    0x00001238 |            42 |   |   |   |   |
       |---|---|---|---|===============|================---|---|---|---|
       ...
```
После возврата из функции локальная переменная `p` будет удалена из памяти, а в
`a` останется измененное значение.
```
    inc(&a);       /* 07 */
}                  /* 08 */
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       ...
       |---|---|---|---|---|---|---|---|= int a ========---|---|---|---|
0x1230 |   |   |   |   |               |            42 |   |   |   |   |
       |---|---|---|---|---|---|---|---|================---|---|---|---|
       ...
```

Мы увидели, что для такой функции как `inc` передача по указателю ничего не
экономит. Такая программа возможно даже будет медленнее, чем вариант без
указателя. Но при работе с [массивами](#массив) и [структурами](#структура)
указатели могут сэкономить много операций копирования.

Указатель - это переменная, содержащая адрес другой переменной в памяти. На
самом деле стандарт C такой нестрогий, что он позволяет хранить в указателе
вообще любой адрес и даже модифицировать его просто записывая в
переменную-указатель значение напрямую. Например, следующий код успешно
скомпилируется:
```c
void inc() {
    int *p = (int *)0x1238;
    *p = *p + 1;
}
void main() {
    int a = 41;
    inc();
}
```

Разумеется, в реальных программах так делать почти никогда не следует по той
причине, что угадать адрес в памяти другой переменной в общем случае
невозможно. Поэтому если вы запустите такую программу, то она закончится
ошибкой. В качестве упражнения проверьте, какая ошибка будет выведена вашей
операционной системой.

Однако, есть случаи, когда обращение по конкретному адресу будет работать.
Например, часть адресов может быть зарезервирована для обращения к различным
устройствам компьютера. Запись и чтение в такие адреса не помещает значения в
оперативную память, а передает их для обработки устройству расширения. C
позволяет манипулировать памятью напрямую, что более строгие языки, вроде Java,
делать не позволяют. Такая нестрогость C - одна из причин его популярности в
низкоуровневой разработке.

# Арифметика указателей

# Массив

Иногда требуется выделить память под несколько значений одного типа. Например,
программе для обработки метеорологических наблюдений нужно сохранить значения
средней температуры в каждый день недели. Использовать для этого 7 переменных
неудобно. В таком случае, можно использовать массив. Объявление массива
начинается с типа его элемента, затем идет имя переменной, а затем - длина
массива в квадратных скобках:
```c
int temp[7];
```

Как и другие переменные массив занимает непрерывную область памяти:

```
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
0x1220 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |= int temp[7] =================================================|
0x1230 |               |               |               |               |
       |===============================================|---|---|---|---|
0x1240 |               |               |               |   |   |   |   |
       |===============================================|---|---|---|---|
0x1250 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
```

Мы видим, что переменная `temp` в памяти представляет собой семь `int`
размещенных в памяти последовательно, то есть `sizeof(int) * 7 = 4 * 7 = 28`
байт. Каждое такое значение типа `int` называется элементом или ячейкой
массива.

Для работы с этими семью `int` в C есть специальный оператор `[]`. Например,
чтобы обратиться к первому элементу массива, нужно написать `temp[0]`, а запись
`temp[6]` обращается к последнему, седьмому элементу. Номер элемента массива,
который мы указываем в квадратных скобках, называется индексом этого элемента.
Рассмотрим код, который пишет и читает элементы массива:
```c
temp[0] = 21;
temp[6] = 27;
int a = temp[0];
```

После выполнения этого кода массив в памяти станет таким:
```
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
0x1220 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |= int temp[7] =================================================|
0x1230 |            21 |               |               |               |
       |===============================================|= int a =======|
0x1240 |               |               |            27 |            21 |
       |===============================================|===============|
0x1250 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
```
На практике запись `temp[<индекс>]` ведёт себя так же как и переменная типа
`int`. То есть массив `int temp[7]` можно считать набором из 7 переменных `int
x`.

Здесь сразу возникает два вопроса. Во-первых, что лежит в ячейках памяти,
которые мы не инициализировали? Ответ на этот вопрос смотри в параграфе про
[инициализацию переменных](#инициализация-переменных). Как и другие переменные
массив можно инициализировать при создании. Для этого нужно присвоить ему
значения элементов, перечисленные в фигурных скобках, например:
```c
int n[7] = { 1, 2, 3, 4, 5, 6, 7 };
```

Второй вопрос: почему нумерация элементов массива начинается с 0, а не с 1?
Чтобы ответить на этот вопрос разберемся с тем как компилятор интерпретирует
запись `temp[6]`. На самом деле, когда компилятор работает с переменной `temp`,
он интерпретирует её как [указатель](#указатель) на значение типа `int`. Но в
отличие от `int *temp` этот указатель не будет явно лежать в памяти. То есть,
для компилятора, записи `int *temp` и `int temp[7]` отличаются тем, что при
второй записи компилятор:
- выделит память из семи значений типа `int` на [стеке](#стек);
- не будет выделять на стеке память под указатель, а вместо этого будет неявно
  его использовать в тех местах, где упоминается `temp`;
- этот указатель будет указывать на первый (нулевой) элемент массива;
- при копировании он будет копировть либо весь массив, либо только указатель,
  зависит от того в переменную какого типа происходит копирование.

Чтобы лучше понять это давайте рассмотрим такой код:
```c
int temp[7] = { 21, 22, 23, 24, 25, 26, 27 };
int *p = temp;
```
Как и сказано выше `temp` и `p` для компилятора взаимозаменяемы, поэтому этот
код успешно скомпилируется. После выполнения этого кода мы получим такую
картину в памяти. Вначале будет лежать массив `temp` из семи элементов, а затем
указатель `p`, который ссылается на начало массива:
```
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
0x1220 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |= int temp[7] =================================================|
0x1230 |            21 |            22 |            23 |            24 |
       |===============================================|= int *p ======|
0x1240 |            25 |            26 |            27 |        0x1230 |
       |===============================================|===============|
0x1250 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
```

Мы даже можем написать `p[6]` и это сработает! Механизм, который работает при
вычислении ячейки по индексу будет одним и тем же. Мы можем написать `p[3] =
34` и заменить четвертое значение в `temp` на 34. Дело в том, что запись `p[x]`
буквально означает следующее: `*(p + x)`. Поскольку адрес при этом вычисляется
из индекса с помощью [арифметики указателей](#арифметика-указателей), то
индексы начинаются с 0, а не с 1. Для простоты в дальнейшем, когда мы будем
говорить, например, про третий элемент массива, мы будем иметь ввиду элемент с
индексом три, то есть четвертый по порядку элемент.

Выше мы говорили о том, что передача массива по указателю может увеличить
производительность. Рассмотрим следующий код:
```c
int sum(int xs[5]) {                /* 1 */
    /* todo */                      /* 2 */
    return 0;                       /* 3 */
}                                   /* 4 */
                                    /* 5 */
void main() {                       /* 6 */
    int ns[5] = { 1, 5, 2, 4, 3 };  /* 7 */
    int s;                          /* 8 */
    s = sum(ns);                    /* 9 */
}                                   /* 10 */
```

После строчки 8 память будет выглядить следующим образом:
```
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       |= int ns[5] ===================================================|
0x1230 |             1 |             5 |             2 |             4 |
       |===============|= int s =======|===============================|
0x1240 |             3 |               |   |   |   |   |   |   |   |   |
       |===============|===============|---|---|---|---|---|---|---|---|
0x1250 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
```
У нас есть массив и переменная `s` для хранения суммы, выделенные на стеке. В
строчке 9 мы вызываем функцию `sum` и в этот момент массив копируется в памяти:
```
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       |= int ns[5] ===================================================|
0x1230 |             1 |             5 |             2 |             4 |
       |===============|= int s =======|= int xs ======================|
0x1240 |             3 |               |             1 |             5 |
       |===============|===============|===============================|
0x1250 |             2 |             4 |             3 |   |   |   |   |
       |===============================================|---|---|---|---|
```
Это происходит потому, что единственный параметр функции `sum` имеет тип
`int[5]`, и это означает, что нужно создать копию массива для вызываемой
функции.

У такого определения `sum` как минимум два недостатка. Во-первых, она не умеет
работать с массивами различной длины. Длина массива закодирована в его типе и в
C нет встроенного типа "массив переменной длины". Во-вторых, как мы видели, при
вызове `sum` весь массив копируется в памяти, а это дополнительный расход
памяти и процессорного времени. Мы можем решить обе проблемы, передав массив с
помощью указателя:
```c
int sum(int *xs, int size) {        /* 1 */
    /* todo */                      /* 2 */
    return 0;                       /* 3 */
}                                   /* 4 */
                                    /* 5 */
void main() {                       /* 6 */
    int ns[5] = { 1, 5, 2, 4, 3 };  /* 7 */
    int s;                          /* 8 */
    s = sum(ns, 5);                 /* 9 */
}                                   /* 10 */
```

Теперь после строчки 9 данные в памяти выглядят гораздо компактнее:
```
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
       |= int ns[5] ===================================================|
0x1230 |             1 |             5 |             2 |             4 |
       |===============|= int s =======|= int *xs =====|= int size ====|
0x1240 |             3 |               |        0x1230 |             5 |
       |===============|===============|===============|===============|
0x1250 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
```
А благодаря тому, что `int *xs` и `int ns[]` ведут себя одинаково, текст
программы практически не изменился.

Особенностью такого способа передачи массива является то, что теперь `sum`
может записать элементы массива через указатель `xs`. Действительно, поскольку
`xs` теперь указывает на `ns`, то `xs[0] = 6` запишет число 6 в нулевой элемент
массива. Это небезопасно, поскольку, если в функции, принимающей массив, будет
ошибка, то она может испортить исходные данные. Чтобы недопустить этого, можно
изменить тип массива и с помощью ключевого слова `const`  указать компилятору,
что по этому указателю можно только читать (смотри [типы
указателей](#типы-указателей):
```c
int sum(int const *xs, int size) {        /* 1 */
```
Теперь при попытке написать `xs[0] = 6` мы получим ошибку компиляции.

Для простоты мы передали длину массива здесь явно как число 5. В реальных
программах так делать небезопасно. В какой-то момент программист может изменить
длину массива и забыть поправить одно из мест, где она используется. Самый
простой способ исправить такую проблему - это использовать
[константу](#константа) для того, чтобы гарантировать, что в обоих случаях
будет использовано одинаковое число. Другой способ - это использование
[sizeof](#sizeof). Чтобы вычислить длину массива во время компиляции, мы можем
поделить размер всего массива в байтах, на размер одного элемента в байтак, то
есть `sizeof(ns)/sizeof(ns[0])`.

# Структура

# Стек

# Инициализация переменных

# sizeof

# Константа

# Типы указателей

`int const * const * a` - как расшифровать

